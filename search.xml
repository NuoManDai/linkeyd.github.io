<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[javascript面向对象]]></title>
      <url>/2016/09/18/javascript-OOP/</url>
      <content type="html"><![CDATA[<p>##OOP浅析</p>
<p>###什么是面向对象<br>面向对象编程（Object Oriented Programming，OOP），我们一般在学习C++和JAVA C#等语言中会经常使用，它 达到了软件工程的三个主要目标：重用性、灵活性和扩展性。它们最大的特点就是：封装 - 继承 - 多态。它比传统的面向过程语言区别于抽象性、封装性、重用性以及便于使用等方面的原因，在复杂的大型系统中能够简化代码使的面向对象编程方式越来越流行。现在也有越来越多的脚本语言采用了面向对象的编程思想让程序由繁化简。</p>
<p>###面向对象编程的原则</p>
<blockquote>
<ul>
<li>开放－封闭原则“Open-Closed Principle” ，接口开放，内容封闭。</li>
<li>里氏代换原则“Liskov Substitution Principle” ，子类型必须能够替换它们的基类型。</li>
<li>依赖倒置原则“Dependence Inversion Principle”，要依赖于抽象，不要依赖于具体。客户端依赖于抽象耦合。</li>
<li>接口隔离原则“Interface Segregation Principle” ，使用多个专一功能的接口比使用一个的总接口总要好。</li>
<li>合成复用原则“Composite Reuse Principle” ，多聚合、少继承。</li>
<li>迪米特原则“Law of Demeter” ，尽可能的减少代码之间的耦合</li>
</ul>
</blockquote>
<p>##javascript OOP</p>
<p>###javascript OOP简介<br>javascript 原本是一门脚本语言，它并不具备OOP的特性，当然随着javascript的不断更新在ES5的时候就已经能够使用特殊的方法编写javascript对象了。目前我先使用ES5语法和ES6的语法分别来实现OOP，其实目前ES6的标准规范已经让javascript更像一门面向对象语言了。如果有JAVA基础的同学直接去观看ES6的基础知识会更加易于理解。</p>
<p>###javascript OOP for ES5</p>
<p>####普通的javascript对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    name : <span class="string">"myName"</span>,</div><div class="line">    age : <span class="string">"11"</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> my = obj;</div><div class="line"><span class="keyword">var</span> my2 = obj;</div><div class="line"><span class="built_in">console</span>.log(my.name); <span class="comment">//myName</span></div><div class="line"><span class="built_in">console</span>.log(my2.name); <span class="comment">//myName</span></div><div class="line">my2.name = <span class="string">"lanling"</span>;</div><div class="line"><span class="built_in">console</span>.log(my.name); <span class="comment">//lanling</span></div><div class="line"><span class="built_in">console</span>.log(my2.name); <span class="comment">//lanling</span></div></pre></td></tr></table></figure></p>
<p>在javascript中对象是由一对花括号，内部由key:value键值对组成，或者可以将对象申明为 <code>new object()</code>,这段代码中我们申明了普通对象<code>obj</code> my、my2都赋值了<code>obj</code>对象，运行两断代码后我们发现他们<code>my.name</code> <code>my2.name</code>的值都是相等当我们为<code>my2.name</code>修改值的时候发现<code>my1</code> <code>my2</code>的值都发生了改变，所有的类型都共用了一个堆内存，当其中一个值改变的时候其他的值也都发生了变化。结果造成了代码的共用，在开发上不利于我们减少代码复用的思想。</p>
<p>####javascript对象的实例化<br>我们在C++中有学过为了对象不使用同一块内存提高代码的复用性，减少代码的耦合度我们会使用实例化对象来对一个对象进行初始化，让它们分别不同分置在不同的堆内存空间当中，在C++中我们创造了构造函数使用<code>Object *object = new  Object()</code>来实例化对象，在javascript中我们也有一种方法来开辟对内存空间建立一个构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyObj = <span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = &#123;</div><div class="line">        name:name,</div><div class="line">        age: age</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> obj</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> my3 = <span class="keyword">new</span> MyObj(<span class="string">"myName"</span>,<span class="string">"11"</span>);</div><div class="line"><span class="keyword">var</span> my4 = <span class="keyword">new</span> MyObj(<span class="string">"myName"</span>,<span class="string">"11"</span>);</div><div class="line"><span class="built_in">console</span>.log(my3.name);<span class="comment">//myName</span></div><div class="line"><span class="built_in">console</span>.log(my4.name);<span class="comment">//myName</span></div><div class="line">my3.name = <span class="string">"langlin"</span>;</div><div class="line"><span class="built_in">console</span>.log(my3.name);<span class="comment">//langlin</span></div><div class="line"><span class="built_in">console</span>.log(my4.name);<span class="comment">//myName</span></div></pre></td></tr></table></figure></p>
<p>上面的代码中我们利用了javascript作用域的特点，对一个方法<code>retrurn obj</code>返回了一个对象，使方法在局部函数之中变成未初始化的状态，之后赋值时利用<code>new</code>运算符实例化了一个对象让它们分置在了不同的堆内存之中，在对<code>my3.name</code>进行赋值时仅仅只影响了该堆内存空间中的值，极大的提高了代码的复用性。</p>
<p>####javascript私有属性方法<br>在面向对象开发中我们需要满足的一个原则也就是开闭原则（接口开放和内容封闭）最简单的理解就是进行封装将实现的内容用私有方法和属性隐藏起来不对外暴露来达到程序的安全。在javascript ES5中没有类的概念，我们可以使用作用域的手段实现私有方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyObj = <span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> privateFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"私有方法无法被直接调用"</span>)</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> obj = &#123;</div><div class="line">        name:name,</div><div class="line">        age: age,</div><div class="line">        private:privateFunction</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> obj</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> my3 = <span class="keyword">new</span> MyObj(<span class="string">"myName"</span>,<span class="string">"11"</span>);</div><div class="line"><span class="built_in">console</span>.log(my3.private());<span class="comment">//私有方法无法被直接调用</span></div><div class="line"><span class="built_in">console</span>.log(my3.privateFunction());<span class="comment">//程序运行出错</span></div></pre></td></tr></table></figure></p>
<p>我们可以看到我们在<code>obj</code>中使用对象<code>private</code>属性引用<code>privateFunction</code>方法在实例化之后使用<code>my3.private()</code>正常调用了内部的私有方法。但是我们在使用<code>my3.privateFunction()</code>的时候直接报错了该方法并没有被对外部开放所以我们无法直接调用，这其实就是利用javascript函数的作用域创造了一个函数的闭包。闭包这个延伸的问题我留着以后再讲吧。</p>
<p>####javascript对象的延伸（原型链）<br>在javascript中我们不得不提的对象生成方法就是原型链了。每个对象都有<code>prototype</code>属性来表示隐式引用（implicit reference），我们将这个引用称之为原型（prototype）。在每个对象之中都有一个<code>__proto__</code>的属性值来实现原型的方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyObj = <span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = &#123;</div><div class="line">        name:name,</div><div class="line">        age: age</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> obj</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> my3 = <span class="keyword">new</span> MyObj(<span class="string">"myName"</span>,<span class="string">"11"</span>);</div><div class="line"><span class="keyword">var</span> my4 = <span class="keyword">new</span> MyObj(<span class="string">"myName"</span>,<span class="string">"11"</span>);</div><div class="line"><span class="comment">//我们在这里申明prototype方法</span></div><div class="line">myObj.prototype.nikeName = <span class="literal">null</span>;</div><div class="line">my3.nikeName = <span class="string">"lanling"</span>;</div><div class="line"><span class="built_in">console</span>.log(my3.nikeName);<span class="comment">//lanling</span></div><div class="line"><span class="built_in">console</span>.log(my4.nikeName);<span class="comment">//undefined</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    name : <span class="string">"myName"</span>,</div><div class="line">    age : <span class="string">"11"</span></div><div class="line">&#125;;</div><div class="line">obj.prototype.nikeName = <span class="string">"error"</span>;</div><div class="line"><span class="built_in">console</span>.log(obj.nikeName);<span class="comment">//程序运行出错</span></div></pre></td></tr></table></figure></p>
<p>在上面程序段中我们用了<code>new</code>运算符给<code>prototype</code>添加对象属性和未使用<code>new</code>运算符添加<code>prototype</code>对象属性，我们可以很直观的看到第二个程序运行发生了错误，从而我们可以了解到<code>prototype</code>必须是对象有经过实例化才可以进行添加。<br>使用技巧：在传统的对象实例化之后对象是不允许添加任何属性和方法，我们如果想给一个对象添加新的方法时可以使用<code>prototype</code>给对象添加更多的属性和让对象实现继承。<br>有了原型链，便可以定义一种所谓的属性隐藏机制，并通过这种机制实现继承。ECMAScript 规定，当要给某个对象的属性赋值时，解释器会查找该对象原型链中第一个含有该属性的对象（注：原型本身就是一个对象，那么原型链即为一组对象的链。对象的原型链中的第一个对象是该对象本身）进行赋值。反之，如果要获取某个对象属性的值，解释器自然是返回该对象原型链中首先具有该属性的对象属性值。</p>
<p>###javascript for ES6</p>
<p>####javascript ES6对象<br>这里是javascript ES6对象的实现，我就直接上注释给各位小伙伴们看吧。在ES6中javascript引入了<code>Class</code>这个概念给javascript看起来更像是一门面向对象的语言，在构造函数上使用<code>constructor()</code>来初始化对象在构造器中我们还可以使用<code>super</code>关键字来继承对象。<br>es6.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;<span class="comment">//函数构造器</span></div><div class="line">        <span class="keyword">super</span>(props)<span class="comment">//继承</span></div><div class="line">        <span class="keyword">this</span>.name = <span class="string">"myName"</span>;</div><div class="line">        <span class="keyword">this</span>.age = <span class="string">"11"</span>;</div><div class="line">    &#125;</div><div class="line">    my()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">        privateFunction();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> privateFunction = ()=&gt;&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"这是一个私有函数"</span>);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Test;<span class="comment">//引出</span></div></pre></td></tr></table></figure></p>
<p>main.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Test <span class="keyword">from</span> <span class="string">'./es6'</span> <span class="comment">//导入</span></div><div class="line"><span class="keyword">var</span> my=<span class="keyword">new</span> Test();</div><div class="line">my.my();<span class="comment">//myName 11 这是一个私有函数</span></div><div class="line">my.privateFunction();<span class="comment">//报错</span></div></pre></td></tr></table></figure></p>
<p>在ES6中我们可以把一个类看成一个整体模块文件由export引出import接收。在ES6中由于没有私有方法的定义，我们该类文件中任意<code>class</code>之外的任意一个地区使用<code>function()</code>来建立一个私有方法，一个文件类中只允许有一个<code>class</code>在类中允许拥有公共方法和构造函数。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2016/09/17/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
